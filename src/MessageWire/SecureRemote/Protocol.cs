/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 *  MessageWire - https://github.com/tylerjensen/MessageWire
 *  
 * The MIT License (MIT)
 * Copyright (C) 2016-2017 Tyler Jensen
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
 * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

using System;
using System.Linq;
using System.Security.Cryptography;

namespace MessageWire.SecureRemote
{
    /// <summary>
    /// Zero knowledge protocol loosely based on secure remote identityKey protocol v6.
    /// </summary>
    public class Protocol
    {
        private readonly SHA256 _sha;
        private readonly MD5 _md5;
        private readonly Random _random;
        private readonly BigInteger _n;

        public Protocol()
        {
            _sha = SHA256.Create();
            _md5 = MD5.Create();
            _random = new Random(DateTime.Now.Millisecond);
            _n = new BigInteger(SafePrimes.N4);
        }

        /// <summary>
        /// Server must generate identityKey hash and store only identity and hash values.
        /// </summary>
        /// <param name="identity"></param>
        /// <param name="identityKey"></param>
        /// <returns></returns>
        public IdentityKeyHash HashCredentials(string identity, string identityKey)
        {
            var salt = ComputeHash(CryptRand());
            var key = ComputeHash(salt, identity.ConvertToBytes(), identityKey.ConvertToBytes());
            var ver = CryptRand();
            return new IdentityKeyHash
            {
                Salt = salt,
                Key = key,
                Verifier = ver
            };
        }


        /// <summary>
        /// Step 1. Client sends identity and ephemeral hash of random number.
        /// </summary>
        /// <param name="aRand">Crypto randum generated by CryptRand() method.</param>
        /// <returns></returns>
        internal byte[] GetClientEphemeralA(byte[] aRand)
        {
            var aval = ComputeHash(aRand);
            return aval;
        }

        /// <summary>
        /// Step 2. Server looks up identity, gets pwd hash, and sends client salt and ephemeral hash of params.
        /// </summary>
        /// <param name="salt"></param>
        /// <param name="verifier"></param>
        /// <param name="bRand">Crypto randum generated by CryptRand() method.</param>
        /// <returns></returns>
        internal byte[] GetServerEphemeralB(byte[] salt, byte[] verifier, byte[] bRand)
        {
            var bval = ComputeHash(salt, verifier, bRand);
            return bval;
        }

        /// <summary>
        /// Step 3. Client and server calculate random scramble of ephemeral hash values exchanged.
        /// </summary>
        /// <param name="ephemeralA"></param>
        /// <param name="ephemeralB"></param>
        /// <returns></returns>
        internal byte[] CalculateRandomScramble(byte[] ephemeralA, byte[] ephemeralB)
        {
            return ComputeShortHash(ephemeralA, ephemeralB);
        }

        /// <summary>
        /// Step 4. Client computes session key
        /// </summary>
        /// <param name="salt"></param>
        /// <param name="identity"></param>
        /// <param name="identityKey"></param>
        /// <param name="aEphemeral"></param>
        /// <param name="bEphemeral"></param>
        /// <param name="uScramble"></param>
        /// <returns></returns>
        internal byte[] ClientComputeSessionKey(byte[] salt, string identity, string identityKey, byte[] aEphemeral, byte[] bEphemeral, byte[] uScramble)
        {
            var key = ComputeHash(salt, identity.ConvertToBytes(), identityKey.ConvertToBytes());
            var kc = ComputeHash(salt, key, aEphemeral, bEphemeral, uScramble);
            return kc;
        }

        /// <summary>
        /// Step 5. Server computes session key
        /// </summary>
        /// <param name="salt"></param>
        /// <param name="key"></param>
        /// <param name="aEphemeral"></param>
        /// <param name="bEphemeral"></param>
        /// <param name="uScramble"></param>
        /// <returns></returns>
        internal byte[] ServerComputeSessionKey(byte[] salt, byte[] key, byte[] aEphemeral, byte[] bEphemeral, byte[] uScramble)
        {
            var ks = ComputeHash(salt, key, aEphemeral, bEphemeral, uScramble);
            return ks;
        }

        /// <summary>
        /// Step 6. Client creates hash of session key and sends to server. Server creates same key and verifies.
        /// </summary>
        /// <param name="identity"></param>
        /// <param name="salt"></param>
        /// <param name="aEphemeral"></param>
        /// <param name="bEphermeral"></param>
        /// <param name="sessionKey"></param>
        /// <returns></returns>
        internal byte[] ClientCreateSessionHash(string identity, byte[] salt, byte[] aEphemeral, byte[] bEphermeral, byte[] sessionKey)
        {
            var mc = ComputeHash(identity.ConvertToBytes(), salt, aEphemeral, bEphermeral, sessionKey);
            return mc;
        }

        /// <summary>
        /// Step 7. Server creates hash of session key and sends to client. Client creates same key and verifies.
        /// </summary>
        /// <param name="aEphemeral"></param>
        /// <param name="clientHash"></param>
        /// <param name="sessionKey"></param>
        /// <returns></returns>
        internal byte[] ServerCreateSessionHash(byte[] aEphemeral, byte[] clientHash, byte[] sessionKey)
        {
            var ms = ComputeHash(aEphemeral, clientHash, sessionKey);
            return ms;
        }

        /// <summary>
        /// Generate crypto safe, pseudo random number.
        /// </summary>
        /// <param name="bits">max value supported is 4096</param>
        /// <returns></returns>
        internal byte[] CryptRand(int bits = 4096)
        {
            var rb = new byte[256];
            _random.NextBytes(rb);
            var bigrand = new BigInteger(rb);
            var crand = (bigrand % SafePrimes.GetSafePrime(_random.Next(0, 2047))) ^  _n;
            var bytes = BigInteger.ToByteArray(crand);
            if (bits >= 4096) return bytes;
            var count = bits / 8;
            var skip = _random.Next(0, bytes.Length - count);
            return bytes.Skip(skip).Take(count).ToArray();
        }

        internal byte[] ComputeShortHash(params byte[][] items)
        {
            var buf = Combine(items);
            return _md5.ComputeHash(buf);
        }

        internal byte[] ComputeHash(params byte[][] items)
        {
            var buf = Combine(items);
            return _sha.ComputeHash(buf);
        }

        internal byte[] Combine(params byte[][] arrays)
        {
            byte[] ret = new byte[arrays.Sum(x => x.Length)];
            int offset = 0;
            foreach (byte[] data in arrays)
            {
                Buffer.BlockCopy(data, 0, ret, offset, data.Length);
                offset += data.Length;
            }
            return ret;
        }
    }
}
